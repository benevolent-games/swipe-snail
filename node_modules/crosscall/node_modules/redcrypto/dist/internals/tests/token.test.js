import { tokenSign } from "../../token-sign.js";
import { tokenVerify } from "../../token-verify.js";
import { tokenDecode } from "../../token-decode.js";
const minute = 60 * 1000;
export const prepareTokenTestingSuite = ({ payload, publicKey, privateKey, }) => ({
    "signed token passes verification": async () => {
        const token = await tokenSign({
            payload,
            privateKey,
            lifespan: minute,
        });
        const payload2 = await tokenVerify({
            token,
            publicKey,
        });
        return (payload2.a === payload.a &&
            payload2.b === payload.b);
    },
    "algorithm 'none' is refused": async () => {
        const token = await tokenSign({
            payload,
            privateKey,
            algorithm: "none",
            lifespan: minute,
        });
        try {
            await tokenVerify({
                token,
                publicKey,
            });
            return false;
        }
        catch (e) {
            return true;
        }
    },
    "expired token fails verification": async () => {
        const token = await tokenSign({
            payload,
            privateKey,
            lifespan: 1 * 1000,
        });
        await nap(1.1 * 1000);
        try {
            await tokenVerify({
                token,
                publicKey,
            });
            return false;
        }
        catch (error) {
            return true;
        }
    },
    "tampered token fails verification": async () => {
        let goodToken = await tokenSign({
            payload,
            privateKey,
            lifespan: minute,
        });
        const badToken = tamperStringHalfway(goodToken);
        try {
            await tokenVerify({
                token: badToken,
                publicKey,
            });
            return false;
        }
        catch (error) {
            return true;
        }
    },
    "decode a token without verification": async () => {
        const token = await tokenSign({
            payload,
            privateKey,
            lifespan: minute,
        });
        const { payload: payload2 } = tokenDecode(token);
        return (payload2.a === payload.a &&
            payload2.b === payload.b);
    },
});
const nap = (milliseconds) => new Promise(resolve => setTimeout(resolve, milliseconds));
function tamperStringHalfway(subject) {
    const { length } = subject;
    return Array.from(subject).map((character, index) => index === Math.floor(length / 2)
        ? "@"
        : character).join("");
}
//# sourceMappingURL=token.test.js.map