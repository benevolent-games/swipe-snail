import { objectMap } from "./internals/object-map.js";
// COMMON
//
export function processPayload(transformer, method) {
    return async (meta, ...args) => {
        const payload = await transformer(meta);
        return method(payload, ...args);
    };
}
export function processPayloadTopic(transformer, topic) {
    return objectMap(topic, method => {
        return processPayload(transformer, method);
    });
}
// CLIENTSIDE
//
export function addMeta(getMeta, method) {
    return async (...args) => method(await getMeta(), ...args);
}
export function addMetaTopic(getMeta, topic) {
    return objectMap(topic, method => addMeta(getMeta, method));
}
export function addMetaApi(getMeta, api) {
    return objectMap(api, topic => addMetaTopic(getMeta, topic));
}
export function declientize(getRequest, processResponse, method) {
    return async (...args) => {
        const response = await method(await getRequest(), ...args);
        return await processResponse(response);
    };
}
export function declientizeTopic(getRequest, processResponse, topic) {
    return objectMap(topic, method => declientize(getRequest, processResponse, method));
}
export function declientizeApi(getRequest, processResponse, api) {
    return objectMap(api, topic => declientizeTopic(getRequest, processResponse, topic));
}
// SERVERSIDE
//
export function serverize(augmentation, method) {
    return async (context, ...args) => {
        const toResponse = await augmentation(context);
        const result = await method(...args);
        return toResponse(result);
    };
}
export function serverizeTopic(augmentation, topic) {
    return objectMap(topic, method => serverize(augmentation, method));
}
export function serverizeApi(augmentation, api) {
    return objectMap(api, topic => serverizeTopic(augmentation, topic));
}
// method curries
//
// // hypothetical augmentations
// //
// function augmentMethodMetaOptionTransform<Meta, Transform, Options extends {}, Args extends any[], Ret>(
// 		method: (options: Options & {transform: Transform}, ...args: Args) => Promise<Ret>,
// 		getTransform: (meta: Meta) => Promise<Transform>,
// 	) {
// 	return async(options: Omit<Options, "transform"> & {meta: Meta}, ...args: Args) => method({
// 		...(<any>options),
// 		transform: await getTransform(options.meta),
// 	}, ...args)
// }
// // meta-as-option curries
// // DEPRECATED
// //
// export function curryTopicMetaOption<T extends Topic, Meta>(
// 		topic: T,
// 		getMeta: () => Promise<Meta>,
// 	): CurryMetaTopic<T> {
// 	return objectMap<T, CurryMetaTopic<T>>(
// 		topic,
// 		method => curryMethodMetaOption(method, getMeta),
// 	)
// }
// export function curryApiMetaOption<A extends Api, Meta>(
// 		api: A,
// 		getMeta: () => Promise<Meta>
// 	): CurryMetaApi<A> {
// 	return objectMap<A, CurryMetaApi<A>>(
// 		api,
// 		topic => curryTopicMetaOption(topic, getMeta)
// 	)
// }
// type CurryMetaApi<A extends Api> = {
// 	[P in keyof A]: CurryMetaTopic<A[P]>
// }
// function curryMethodMetaOption<Meta, Options extends {}, Args extends any[], Ret>(
// 		method: (options: Options & {meta: Meta}, ...args: Args) => Promise<Ret>,
// 		getMeta: () => Promise<Meta>,
// 	) {
// 	return async(options: Omit<Options, "meta">, ...args: Args) => method({
// 		...(<Options>options),
// 		meta: await getMeta(),
// 	}, ...args)
// }
//# sourceMappingURL=curries.js.map